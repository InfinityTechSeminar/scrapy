{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>Try this: </p>\n\n<pre><code>console=Hostdata(hw_id = i[0],location_id = i[1],consoleip = i[2],biosversion = i[3])\n</code></pre>\n\n<p>You are trying to assign the value to the value that the variable holds instead of the value to the variable. Basically, the &lt;&gt; is console.</p>\n    </div>", "qid": 48515893, "link": "https://stackoverflow.com/a/48515962", "id": 48515962}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>The number 49166 is the port number on the URL.</p>\n\n<p>Your ROOT_URL should be:</p>\n\n<pre><code>String ROOT_URL = \"http://makecodeeasy.com:49166\";\n</code></pre>\n\n<p>And use Retrofit as:</p>\n\n<pre><code>@POST(\"api/Customers\")\nObservable&lt;LoginResponse&gt;\nlogin( @Body LoginRequest loginRequest);\n</code></pre>\n    </div>", "qid": 48515894, "link": "https://stackoverflow.com/a/48515965", "id": 48515965}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>click the phone+tablet icon in chrome dev tools to enter device emulation mode. You can then enter custom sizes. You cannot do that programatically.</p>\n    </div>", "qid": 48515901, "link": "https://stackoverflow.com/a/48515996", "id": 48515996}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>By using the <code>merge</code> function and its optional parameters:</p>\n\n<p><strong><em>Inner join:</em></strong> <code>merge(df1, df2)</code> will work for these examples because R automatically joins the frames by common variable names, but you would most likely want to specify <code>merge(df1, df2, by = \"CustomerId\")</code> to make sure that you were matching on only the fields you desired.  You can also use the <code>by.x</code> and <code>by.y</code> parameters if the matching variables have different names in the different data frames.</p>\n\n<p><strong><em>Outer join:</em></strong> <code>merge(x = df1, y = df2, by = \"CustomerId\", all = TRUE)</code></p>\n\n<p><strong><em>Left outer:</em></strong> <code>merge(x = df1, y = df2, by = \"CustomerId\", all.x = TRUE)</code></p>\n\n<p><strong><em>Right outer:</em></strong> <code>merge(x = df1, y = df2, by = \"CustomerId\", all.y = TRUE)</code></p>\n\n<p><strong><em>Cross join:</em></strong> <code>merge(x = df1, y = df2, by = NULL)</code></p>\n\n<p><strike>Just as with the inner join, you would probably want to explicitly pass \"CustomerId\" to R as the matching variable.</strike>  I think it's almost always best to explicitly state the identifiers on which you want to merge; it's safer if the input data.frames change unexpectedly and easier to read later on.</p>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>I would recommend checking out <a href=\"http://cran.r-project.org/web/packages/sqldf/index.html\" rel=\"noreferrer\">Gabor Grothendieck's sqldf package</a>, which allows you to express these operations in SQL.</p>\n\n<pre><code>library(sqldf)\n\n## inner join\ndf3 &lt;- sqldf(\"SELECT CustomerId, Product, State \n              FROM df1\n              JOIN df2 USING(CustomerID)\")\n\n## left join (substitute 'right' for right join)\ndf4 &lt;- sqldf(\"SELECT CustomerId, Product, State \n              FROM df1\n              LEFT JOIN df2 USING(CustomerID)\")\n</code></pre>\n\n<p>I find the SQL syntax to be simpler and more natural than its R equivalent (but this may just reflect my RDBMS bias).</p>\n\n<p>See <a href=\"https://github.com/ggrothendieck/sqldf#example-4-join\" rel=\"noreferrer\">Gabor's sqldf GitHub</a> for more information on joins. </p>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>There is the <strong>data.table</strong> approach for an inner join, which is very time and memory efficient (and necessary for some larger data.frames):</p>\n\n<pre><code>library(data.table)\n\ndt1 &lt;- data.table(df1, key = \"CustomerId\") \ndt2 &lt;- data.table(df2, key = \"CustomerId\")\n\njoined.dt1.dt.2 &lt;- dt1[dt2]\n</code></pre>\n\n<p><code>merge</code> also works on data.tables (as it is generic and calls <code>merge.data.table</code>)</p>\n\n<pre><code>merge(dt1, dt2)\n</code></pre>\n\n<p>data.table documented on stackoverflow:<br>\n<a href=\"https://stackoverflow.com/questions/2232699/r-how-to-do-a-data-table-merge-operation\">How to do a data.table merge operation</a><br>\n<a href=\"https://stackoverflow.com/questions/9914734/translating-sql-joins-on-foreign-keys-to-r-data-table-syntax\">Translating SQL joins on foreign keys to R data.table syntax</a><br>\n<a href=\"https://stackoverflow.com/questions/11146967/efficient-alternatives-to-merge-for-larger-data-frames-r\">Efficient alternatives to merge for larger data.frames R</a><br>\n<a href=\"https://stackoverflow.com/questions/7090621/how-to-do-a-basic-left-outer-join-with-data-table-in-r\">How to do a basic left outer join with data.table in R?</a></p>\n\n<p>Yet another option is the <code>join</code> function found in the <a href=\"http://cran.r-project.org/web/packages/plyr/index.html\" rel=\"noreferrer\"><strong>plyr</strong></a> package</p>\n\n<pre><code>library(plyr)\n\njoin(df1, df2,\n     type = \"inner\")\n\n#   CustomerId Product   State\n# 1          2 Toaster Alabama\n# 2          4   Radio Alabama\n# 3          6   Radio    Ohio\n</code></pre>\n\n<p>Options for <code>type</code>: <code>inner</code>, <code>left</code>, <code>right</code>, <code>full</code>.</p>\n\n<p>From <code>?join</code>: Unlike <code>merge</code>, [<code>join</code>] preserves the order of x no matter what join type is used.</p>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>You can do joins as well using Hadley Wickham's awesome <a href=\"http://blog.rstudio.org/2014/01/17/introducing-dplyr/\">dplyr</a> package.  </p>\n\n<pre><code>library(dplyr)\n\n#make sure that CustomerId cols are both type numeric\n#they ARE not using the provided code in question and dplyr will complain\ndf1$CustomerId &lt;- as.numeric(df1$CustomerId)\ndf2$CustomerId &lt;- as.numeric(df2$CustomerId)\n</code></pre>\n\n<h2>Mutating joins: add columns to df1 using matches in df2</h2>\n\n<pre><code>#inner\ninner_join(df1, df2)\n\n#left outer\nleft_join(df1, df2)\n\n#right outer\nright_join(df1, df2)\n\n#alternate right outer\nleft_join(df2, df1)\n\n#full join\nfull_join(df1, df2)\n</code></pre>\n\n<h2>Filtering joins: filter out rows in df1, don't modify columns</h2>\n\n<pre><code>semi_join(df1, df2) #keep only observations in df1 that match in df2.\nanti_join(df1, df2) #drops all observations in df1 that match in df2.\n</code></pre>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>There are some good examples of doing this over at the <a href=\"http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge\" rel=\"noreferrer\">R Wiki</a>. I'll steal a couple here:</p>\n\n<p><strong>Merge Method</strong></p>\n\n<p>Since your keys are named the same the short way to do an inner join is merge():</p>\n\n<pre><code>merge(df1,df2)\n</code></pre>\n\n<p>a full inner join (all records from both tables) can be created with the \"all\" keyword:</p>\n\n<pre><code>merge(df1,df2, all=TRUE)\n</code></pre>\n\n<p>a left outer join of df1 and df2:</p>\n\n<pre><code>merge(df1,df2, all.x=TRUE)\n</code></pre>\n\n<p>a right outer join of df1 and df2:</p>\n\n<pre><code>merge(df1,df2, all.y=TRUE)\n</code></pre>\n\n<p>you can flip 'em, slap 'em and rub 'em down to get the other two outer joins you asked about :)</p>\n\n<p><strong>Subscript Method</strong></p>\n\n<p>A left outer join with df1 on the left using a subscript method would be:</p>\n\n<pre><code>df1[,\"State\"]&lt;-df2[df1[ ,\"Product\"], \"State\"]\n</code></pre>\n\n<p>The other combination of outer joins can be created by mungling the left outer join subscript example. (yeah, I know that's the equivalent of saying \"I'll leave it as an exercise for the reader...\")</p>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>New in 2014: </p>\n\n<p>Especially if you're also interested in data manipulation in general (including sorting, filtering, subsetting, summarizing etc.), you should definitely take a look at <code>dplyr</code>, which comes with a variety of functions all designed to facilitate your work specifically with data frames and certain other database types. It even offers quite an elaborate SQL interface, and even a function to convert (most) SQL code directly into R.</p>\n\n<p>The four joining-related functions in the dplyr package are (to quote):</p>\n\n<ul>\n<li><code>inner_join(x, y, by = NULL, copy = FALSE, ...)</code>: return all rows from\nx where there are matching values in y, and all columns from x and y </li>\n<li><code>left_join(x, y, by = NULL, copy = FALSE, ...)</code>: return all rows from x, and all columns from x and y </li>\n<li><code>semi_join(x, y, by = NULL, copy = FALSE, ...)</code>: return all rows from x where there are matching values in\ny, keeping just columns from x.  </li>\n<li><code>anti_join(x, y, by = NULL, copy = FALSE, ...)</code>: return all rows from x\nwhere there are not matching values in y, keeping just columns from x</li>\n</ul>\n\n<p>It's all <a href=\"http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html\" rel=\"noreferrer\">here</a> in great detail.</p>\n\n<p>Selecting columns can be done by <code>select(df,\"column\")</code>. If that's not SQL-ish enough for you, then there's the <code>sql()</code> function, into which you can enter SQL code as-is, and it will do the operation you specified just like you were writing in R all along (for more information, please refer to the <a href=\"http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html\" rel=\"noreferrer\">dplyr/databases vignette</a>). For example, if applied correctly, <code>sql(\"SELECT * FROM hflights\")</code> will select all the columns from the \"hflights\" dplyr table (a \"tbl\").</p>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>Update on data.table methods for joining datasets. See below examples for each type of join. There are two methods, one from <code>[.data.table</code> when passing second data.table as the first argument to subset, another way is to use <code>merge</code> function which dispatched to fast data.table method.  </p>\n\n<p><strong>Update on 2016-04-01 - and it isn't April Fools joke!</strong><br>\nIn 1.9.7 version of data.table joins are now capable to use existing index which tremendously reduce the timing of a join. <strong>Below code and benchmark does NOT use data.table indices on join</strong>. If you are looking for near real-time join you should use data.table indices.</p>\n\n<p></p>\n\n<pre><code>df1 = data.frame(CustomerId = c(1:6), Product = c(rep(\"Toaster\", 3), rep(\"Radio\", 3)))\ndf2 = data.frame(CustomerId = c(2L, 4L, 7L), State = c(rep(\"Alabama\", 2), rep(\"Ohio\", 1))) # one value changed to show full outer join\n\nlibrary(data.table)\n\ndt1 = as.data.table(df1)\ndt2 = as.data.table(df2)\nsetkey(dt1, CustomerId)\nsetkey(dt2, CustomerId)\n# right outer join keyed data.tables\ndt1[dt2]\n\nsetkey(dt1, NULL)\nsetkey(dt2, NULL)\n# right outer join unkeyed data.tables - use `on` argument\ndt1[dt2, on = \"CustomerId\"]\n\n# left outer join - swap dt1 with dt2\ndt2[dt1, on = \"CustomerId\"]\n\n# inner join - use `nomatch` argument\ndt1[dt2, nomatch=0L, on = \"CustomerId\"]\n\n# anti join - use `!` operator\ndt1[!dt2, on = \"CustomerId\"]\n\n# inner join\nmerge(dt1, dt2, by = \"CustomerId\")\n\n# full outer join\nmerge(dt1, dt2, by = \"CustomerId\", all = TRUE)\n\n# see ?merge.data.table arguments for other cases\n</code></pre>\n\n<p>Below benchmark tests base R, sqldf, dplyr and data.table.<br>\nBenchmark tests unkeyed/unindexed datasets. You can get even better performance if you are using keys on your data.tables or indexes with sqldf. Base R and dplyr does not have indexes or keys so I did not include that scenario in benchmark.<br>\nBenchmark is performed on 5M-1 rows datasets, there are 5M-2 common values on join column so each scenario (left, right, full, inner) can be tested and join is still not trivial to perform.  </p>\n\n<p></p>\n\n<pre><code>library(microbenchmark)\nlibrary(sqldf)\nlibrary(dplyr)\nlibrary(data.table)\n\nn = 5e6\nset.seed(123)\ndf1 = data.frame(x=sample(n,n-1L), y1=rnorm(n-1L))\ndf2 = data.frame(x=sample(n,n-1L), y2=rnorm(n-1L))\ndt1 = as.data.table(df1)\ndt2 = as.data.table(df2)\n\n# inner join\nmicrobenchmark(times = 10L,\n               base = merge(df1, df2, by = \"x\"),\n               sqldf = sqldf(\"SELECT * FROM df1 INNER JOIN df2 ON df1.x = df2.x\"),\n               dplyr = inner_join(df1, df2, by = \"x\"),\n               data.table = dt1[dt2, nomatch = 0L, on = \"x\"])\n#Unit: milliseconds\n#       expr        min         lq      mean     median        uq       max neval\n#       base 15546.0097 16083.4915 16687.117 16539.0148 17388.290 18513.216    10\n#      sqldf 44392.6685 44709.7128 45096.401 45067.7461 45504.376 45563.472    10\n#      dplyr  4124.0068  4248.7758  4281.122  4272.3619  4342.829  4411.388    10\n# data.table   937.2461   946.0227  1053.411   973.0805  1214.300  1281.958    10\n\n# left outer join\nmicrobenchmark(times = 10L,\n               base = merge(df1, df2, by = \"x\", all.x = TRUE),\n               sqldf = sqldf(\"SELECT * FROM df1 LEFT OUTER JOIN df2 ON df1.x = df2.x\"),\n               dplyr = left_join(df1, df2, by = c(\"x\"=\"x\")),\n               data.table = dt2[dt1, on = \"x\"])\n#Unit: milliseconds\n#       expr       min         lq       mean     median         uq       max neval\n#       base 16140.791 17107.7366 17441.9538 17414.6263 17821.9035 19453.034    10\n#      sqldf 43656.633 44141.9186 44777.1872 44498.7191 45288.7406 47108.900    10\n#      dplyr  4062.153  4352.8021  4780.3221  4409.1186  4450.9301  8385.050    10\n# data.table   823.218   823.5557   901.0383   837.9206   883.3292  1277.239    10\n\n# right outer join\nmicrobenchmark(times = 10L,\n               base = merge(df1, df2, by = \"x\", all.y = TRUE),\n               sqldf = sqldf(\"SELECT * FROM df2 LEFT OUTER JOIN df1 ON df2.x = df1.x\"),\n               dplyr = right_join(df1, df2, by = \"x\"),\n               data.table = dt1[dt2, on = \"x\"])\n#Unit: milliseconds\n#       expr        min         lq       mean     median        uq       max neval\n#       base 15821.3351 15954.9927 16347.3093 16044.3500 16621.887 17604.794    10\n#      sqldf 43635.5308 43761.3532 43984.3682 43969.0081 44044.461 44499.891    10\n#      dplyr  3936.0329  4028.1239  4102.4167  4045.0854  4219.958  4307.350    10\n# data.table   820.8535   835.9101   918.5243   887.0207  1005.721  1068.919    10\n\n# full outer join\nmicrobenchmark(times = 10L,\n               base = merge(df1, df2, by = \"x\", all = TRUE),\n               #sqldf = sqldf(\"SELECT * FROM df1 FULL OUTER JOIN df2 ON df1.x = df2.x\"), # not supported\n               dplyr = full_join(df1, df2, by = \"x\"),\n               data.table = merge(dt1, dt2, by = \"x\", all = TRUE))\n#Unit: seconds\n#       expr       min        lq      mean    median        uq       max neval\n#       base 16.176423 16.908908 17.485457 17.364857 18.271790 18.626762    10\n#      dplyr  7.610498  7.666426  7.745850  7.710638  7.832125  7.951426    10\n# data.table  2.052590  2.130317  2.352626  2.208913  2.470721  2.951948    10\n</code></pre>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>dplyr is very good and performant. In addition to the other answers on it, here was/is its status as of </p>\n\n<p><strong><em>v0.1.3</em></strong> (4/2014)</p>\n\n<ul>\n<li>has <strong>inner_join, left_join, semi_join, anti_join</strong></li>\n<li><strong>outer_join</strong> not implemented yet, fallback is use base::merge() (or plyr::join())</li>\n<li><a href=\"https://groups.google.com/forum/#!topic/manipulatr/OuAPC4VyfIc\">Hadley mentioning other advantages here</a></li>\n<li>one minor feature merge currently has that dplyr doesn't is <a href=\"https://github.com/hadley/dplyr/issues/177\">the ability to have separate by.x,by.y columns</a> as e.g. Python pandas does.</li>\n<li><a href=\"https://github.com/hadley/dplyr/issues/96\">Implement right_join and <strong>outer_join</strong></a> is tagged for v0.3 (presumably at least 2015 or beyond)</li>\n</ul>\n\n<p>Per hadley's comments in that issue:</p>\n\n<ul>\n<li><strong>right_join</strong>(x,y) is the same as left_join(y,x) in terms of the rows, just the columns will be different orders. Easily worked around with select(new_column_order)</li>\n<li><strong>outer_join</strong> is basically union(left_join(x, y), right_join(x, y)) - i.e. preserve all rows in both data frames.</li>\n</ul>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>In joining two data frames with ~1 million rows each, one with 2 columns and the other with ~20, I've surprisingly found <code>merge(..., all.x = TRUE, all.y = TRUE)</code> to be faster then <code>dplyr::full_join()</code>. This is with dplyr v0.4 </p>\n\n<p>Merge takes ~17 seconds, full_join takes ~65 seconds.  </p>\n\n<p>Some food for though, since I generally default to dplyr for manipulation tasks.</p>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>For the case of a left join with a <code>0..*:0..1</code> cardinality or a right join with a <code>0..1:0..*</code> cardinality it is possible to assign in-place the unilateral columns from the joiner (the <code>0..1</code> table) directly onto the joinee (the <code>0..*</code> table), and thereby avoid the creation of an entirely new table of data. This requires matching the key columns from the joinee into the joiner and indexing+ordering the joiner's rows accordingly for the assignment.</p>\n\n<p>If the key is a single column, then we can use a single call to <a href=\"https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html\" rel=\"noreferrer\"><code>match()</code></a> to do the matching. This is the case I'll cover in this answer.</p>\n\n<p>Here's an example based on the OP, except I've added an extra row to <code>df2</code> with an id of 7 to test the case of a non-matching key in the joiner. This is effectively <code>df1</code> left join <code>df2</code>:</p>\n\n<pre><code>df1 &lt;- data.frame(CustomerId=1:6,Product=c(rep('Toaster',3L),rep('Radio',3L)));\ndf2 &lt;- data.frame(CustomerId=c(2L,4L,6L,7L),State=c(rep('Alabama',2L),'Ohio','Texas'));\ndf1[names(df2)[-1L]] &lt;- df2[match(df1[,1L],df2[,1L]),-1L];\ndf1;\n##   CustomerId Product   State\n## 1          1 Toaster    &lt;NA&gt;\n## 2          2 Toaster Alabama\n## 3          3 Toaster    &lt;NA&gt;\n## 4          4   Radio Alabama\n## 5          5   Radio    &lt;NA&gt;\n## 6          6   Radio    Ohio\n</code></pre>\n\n<p>In the above I hard-coded an assumption that the key column is the first column of both input tables. I would argue that, in general, this is not an unreasonable assumption, since, if you have a data.frame with a key column, it would be strange if it had not been set up as the first column of the data.frame from the outset. And you can always reorder the columns to make it so. An advantageous consequence of this assumption is that the name of the key column does not have to be hard-coded, although I suppose it's just replacing one assumption with another. Concision is another advantage of integer indexing, as well as speed. In the benchmarks below I'll change the implementation to use string name indexing to match the competing implementations.</p>\n\n<p>I think this is a particularly appropriate solution if you have several tables that you want to left join against a single large table. Repeatedly rebuilding the entire table for each merge would be unnecessary and inefficient.</p>\n\n<p>On the other hand, if you need the joinee to remain unaltered through this operation for whatever reason, then this solution cannot be used, since it modifies the joinee directly. Although in that case you could simply make a copy and perform the in-place assignment(s) on the copy.</p>\n\n<hr>\n\n<p>As a side note, I briefly looked into possible matching solutions for multicolumn keys. Unfortunately, the only matching solutions I found were:</p>\n\n<ul>\n<li>inefficient concatenations. e.g. <code>match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))</code>, or the same idea with <code>paste()</code>.</li>\n<li>inefficient cartesian conjunctions, e.g. <code>outer(df1$a,df2$a,`==`) &amp; outer(df1$b,df2$b,`==`)</code>.</li>\n<li>base R <code>merge()</code> and equivalent package-based merge functions, which always allocate a new table to return the merged result, and thus are not suitable for an in-place assignment-based solution.</li>\n</ul>\n\n<p>For example, see <a href=\"https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r\">Matching multiple columns on different data frames and getting other column as result</a>, <a href=\"https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns\">match two columns with two other columns</a>, <a href=\"https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html\" rel=\"noreferrer\">Matching on multiple columns</a>, and the dupe of this question where I originally came up with the in-place solution, <a href=\"https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281\">Combine two data frames with different number of rows in R</a>.</p>\n\n<hr>\n\n<h1>Benchmarking</h1>\n\n<p>I decided to do my own benchmarking to see how the in-place assignment approach compares to the other solutions that have been offered in this question.</p>\n\n<p>Testing code:</p>\n\n<pre><code>library(microbenchmark);\nlibrary(data.table);\nlibrary(sqldf);\nlibrary(plyr);\nlibrary(dplyr);\n\nsolSpecs &lt;- list(\n    merge=list(testFuncs=list(\n        inner=function(df1,df2,key) merge(df1,df2,key),\n        left =function(df1,df2,key) merge(df1,df2,key,all.x=T),\n        right=function(df1,df2,key) merge(df1,df2,key,all.y=T),\n        full =function(df1,df2,key) merge(df1,df2,key,all=T)\n    )),\n    data.table.unkeyed=list(argSpec='data.table.unkeyed',testFuncs=list(\n        inner=function(dt1,dt2,key) dt1[dt2,on=key,nomatch=0L,allow.cartesian=T],\n        left =function(dt1,dt2,key) dt2[dt1,on=key,allow.cartesian=T],\n        right=function(dt1,dt2,key) dt1[dt2,on=key,allow.cartesian=T],\n        full =function(dt1,dt2,key) merge(dt1,dt2,key,all=T,allow.cartesian=T) ## calls merge.data.table()\n    )),\n    data.table.keyed=list(argSpec='data.table.keyed',testFuncs=list(\n        inner=function(dt1,dt2) dt1[dt2,nomatch=0L,allow.cartesian=T],\n        left =function(dt1,dt2) dt2[dt1,allow.cartesian=T],\n        right=function(dt1,dt2) dt1[dt2,allow.cartesian=T],\n        full =function(dt1,dt2) merge(dt1,dt2,all=T,allow.cartesian=T) ## calls merge.data.table()\n    )),\n    sqldf.unindexed=list(testFuncs=list( ## note: must pass connection=NULL to avoid running against the live DB connection, which would result in collisions with the residual tables from the last query upload\n        inner=function(df1,df2,key) sqldf(paste0('select * from df1 inner join df2 using(',paste(collapse=',',key),')'),connection=NULL),\n        left =function(df1,df2,key) sqldf(paste0('select * from df1 left join df2 using(',paste(collapse=',',key),')'),connection=NULL),\n        right=function(df1,df2,key) sqldf(paste0('select * from df2 left join df1 using(',paste(collapse=',',key),')'),connection=NULL) ## can't do right join proper, not yet supported; inverted left join is equivalent\n        ##full =function(df1,df2,key) sqldf(paste0('select * from df1 full join df2 using(',paste(collapse=',',key),')'),connection=NULL) ## can't do full join proper, not yet supported; possible to hack it with a union of left joins, but too unreasonable to include in testing\n    )),\n    sqldf.indexed=list(testFuncs=list( ## important: requires an active DB connection with preindexed main.df1 and main.df2 ready to go; arguments are actually ignored\n        inner=function(df1,df2,key) sqldf(paste0('select * from main.df1 inner join main.df2 using(',paste(collapse=',',key),')')),\n        left =function(df1,df2,key) sqldf(paste0('select * from main.df1 left join main.df2 using(',paste(collapse=',',key),')')),\n        right=function(df1,df2,key) sqldf(paste0('select * from main.df2 left join main.df1 using(',paste(collapse=',',key),')')) ## can't do right join proper, not yet supported; inverted left join is equivalent\n        ##full =function(df1,df2,key) sqldf(paste0('select * from main.df1 full join main.df2 using(',paste(collapse=',',key),')')) ## can't do full join proper, not yet supported; possible to hack it with a union of left joins, but too unreasonable to include in testing\n    )),\n    plyr=list(testFuncs=list(\n        inner=function(df1,df2,key) join(df1,df2,key,'inner'),\n        left =function(df1,df2,key) join(df1,df2,key,'left'),\n        right=function(df1,df2,key) join(df1,df2,key,'right'),\n        full =function(df1,df2,key) join(df1,df2,key,'full')\n    )),\n    dplyr=list(testFuncs=list(\n        inner=function(df1,df2,key) inner_join(df1,df2,key),\n        left =function(df1,df2,key) left_join(df1,df2,key),\n        right=function(df1,df2,key) right_join(df1,df2,key),\n        full =function(df1,df2,key) full_join(df1,df2,key)\n    )),\n    in.place=list(testFuncs=list(\n        left =function(df1,df2,key) { cns &lt;- setdiff(names(df2),key); df1[cns] &lt;- df2[match(df1[,key],df2[,key]),cns]; df1; },\n        right=function(df1,df2,key) { cns &lt;- setdiff(names(df1),key); df2[cns] &lt;- df1[match(df2[,key],df1[,key]),cns]; df2; }\n    ))\n);\n\ngetSolTypes &lt;- function() names(solSpecs);\ngetJoinTypes &lt;- function() unique(unlist(lapply(solSpecs,function(x) names(x$testFuncs))));\ngetArgSpec &lt;- function(argSpecs,key=NULL) if (is.null(key)) argSpecs$default else argSpecs[[key]];\n\ninitSqldf &lt;- function() {\n    sqldf(); ## creates sqlite connection on first run, cleans up and closes existing connection otherwise\n    if (exists('sqldfInitFlag',envir=globalenv(),inherits=F) &amp;&amp; sqldfInitFlag) { ## false only on first run\n        sqldf(); ## creates a new connection\n    } else {\n        assign('sqldfInitFlag',T,envir=globalenv()); ## set to true for the one and only time\n    }; ## end if\n    invisible();\n}; ## end initSqldf()\n\nsetUpBenchmarkCall &lt;- function(argSpecs,joinType,solTypes=getSolTypes(),env=parent.frame()) {\n    ## builds and returns a list of expressions suitable for passing to the list argument of microbenchmark(), and assigns variables to resolve symbol references in those expressions\n    callExpressions &lt;- list();\n    nms &lt;- character();\n    for (solType in solTypes) {\n        testFunc &lt;- solSpecs[[solType]]$testFuncs[[joinType]];\n        if (is.null(testFunc)) next; ## this join type is not defined for this solution type\n        testFuncName &lt;- paste0('tf.',solType);\n        assign(testFuncName,testFunc,envir=env);\n        argSpecKey &lt;- solSpecs[[solType]]$argSpec;\n        argSpec &lt;- getArgSpec(argSpecs,argSpecKey);\n        argList &lt;- setNames(nm=names(argSpec$args),vector('list',length(argSpec$args)));\n        for (i in seq_along(argSpec$args)) {\n            argName &lt;- paste0('tfa.',argSpecKey,i);\n            assign(argName,argSpec$args[[i]],envir=env);\n            argList[[i]] &lt;- if (i%in%argSpec$copySpec) call('copy',as.symbol(argName)) else as.symbol(argName);\n        }; ## end for\n        callExpressions[[length(callExpressions)+1L]] &lt;- do.call(call,c(list(testFuncName),argList),quote=T);\n        nms[length(nms)+1L] &lt;- solType;\n    }; ## end for\n    names(callExpressions) &lt;- nms;\n    callExpressions;\n}; ## end setUpBenchmarkCall()\n\nharmonize &lt;- function(res) {\n    res &lt;- as.data.frame(res); ## coerce to data.frame\n    for (ci in which(sapply(res,is.factor))) res[[ci]] &lt;- as.character(res[[ci]]); ## coerce factor columns to character\n    for (ci in which(sapply(res,is.logical))) res[[ci]] &lt;- as.integer(res[[ci]]); ## coerce logical columns to integer (works around sqldf quirk of munging logicals to integers)\n    ##for (ci in which(sapply(res,inherits,'POSIXct'))) res[[ci]] &lt;- as.double(res[[ci]]); ## coerce POSIXct columns to double (works around sqldf quirk of losing POSIXct class) ----- POSIXct doesn't work at all in sqldf.indexed\n    res &lt;- res[order(names(res))]; ## order columns\n    res &lt;- res[do.call(order,res),]; ## order rows\n    res;\n}; ## end harmonize()\n\ncheckIdentical &lt;- function(argSpecs,solTypes=getSolTypes()) {\n    for (joinType in getJoinTypes()) {\n        callExpressions &lt;- setUpBenchmarkCall(argSpecs,joinType,solTypes);\n        if (length(callExpressions)&lt;2L) next;\n        ex &lt;- harmonize(eval(callExpressions[[1L]]));\n        for (i in seq(2L,len=length(callExpressions)-1L)) {\n            y &lt;- harmonize(eval(callExpressions[[i]]));\n            if (!isTRUE(all.equal(ex,y,check.attributes=F))) {\n                ex &lt;&lt;- ex;\n                y &lt;&lt;- y;\n                solType &lt;- names(callExpressions)[i];\n                stop(paste0('non-identical: ',solType,' ',joinType,'.'));\n            }; ## end if\n        }; ## end for\n    }; ## end for\n    invisible();\n}; ## end checkIdentical()\n\ntestJoinType &lt;- function(argSpecs,joinType,solTypes=getSolTypes(),metric=NULL,times=100L) {\n    callExpressions &lt;- setUpBenchmarkCall(argSpecs,joinType,solTypes);\n    bm &lt;- microbenchmark(list=callExpressions,times=times);\n    if (is.null(metric)) return(bm);\n    bm &lt;- summary(bm);\n    res &lt;- setNames(nm=names(callExpressions),bm[[metric]]);\n    attr(res,'unit') &lt;- attr(bm,'unit');\n    res;\n}; ## end testJoinType()\n\ntestAllJoinTypes &lt;- function(argSpecs,solTypes=getSolTypes(),metric=NULL,times=100L) {\n    joinTypes &lt;- getJoinTypes();\n    resList &lt;- setNames(nm=joinTypes,lapply(joinTypes,function(joinType) testJoinType(argSpecs,joinType,solTypes,metric,times)));\n    if (is.null(metric)) return(resList);\n    units &lt;- unname(unlist(lapply(resList,attr,'unit')));\n    res &lt;- do.call(data.frame,c(list(join=joinTypes),setNames(nm=solTypes,rep(list(rep(NA_real_,length(joinTypes))),length(solTypes))),list(unit=units,stringsAsFactors=F)));\n    for (i in seq_along(resList)) res[i,match(names(resList[[i]]),names(res))] &lt;- resList[[i]];\n    res;\n}; ## end testAllJoinTypes()\n\ntestGrid &lt;- function(makeArgSpecsFunc,sizes,overlaps,solTypes=getSolTypes(),joinTypes=getJoinTypes(),metric='median',times=100L) {\n\n    res &lt;- expand.grid(size=sizes,overlap=overlaps,joinType=joinTypes,stringsAsFactors=F);\n    res[solTypes] &lt;- NA_real_;\n    res$unit &lt;- NA_character_;\n    for (ri in seq_len(nrow(res))) {\n\n        size &lt;- res$size[ri];\n        overlap &lt;- res$overlap[ri];\n        joinType &lt;- res$joinType[ri];\n\n        argSpecs &lt;- makeArgSpecsFunc(size,overlap);\n\n        checkIdentical(argSpecs,solTypes);\n\n        cur &lt;- testJoinType(argSpecs,joinType,solTypes,metric,times);\n        res[ri,match(names(cur),names(res))] &lt;- cur;\n        res$unit[ri] &lt;- attr(cur,'unit');\n\n    }; ## end for\n\n    res;\n\n}; ## end testGrid()\n</code></pre>\n\n<hr>\n\n<p>Here's a benchmark of the example based on the OP that I demonstrated earlier:</p>\n\n<pre><code>## OP's example, supplemented with a non-matching row in df2\nargSpecs &lt;- list(\n    default=list(copySpec=1:2,args=list(\n        df1 &lt;- data.frame(CustomerId=1:6,Product=c(rep('Toaster',3L),rep('Radio',3L))),\n        df2 &lt;- data.frame(CustomerId=c(2L,4L,6L,7L),State=c(rep('Alabama',2L),'Ohio','Texas')),\n        'CustomerId'\n    )),\n    data.table.unkeyed=list(copySpec=1:2,args=list(\n        as.data.table(df1),\n        as.data.table(df2),\n        'CustomerId'\n    )),\n    data.table.keyed=list(copySpec=1:2,args=list(\n        setkey(as.data.table(df1),CustomerId),\n        setkey(as.data.table(df2),CustomerId)\n    ))\n);\n## prepare sqldf\ninitSqldf();\nsqldf('create index df1_key on df1(CustomerId);'); ## upload and create an sqlite index on df1\nsqldf('create index df2_key on df2(CustomerId);'); ## upload and create an sqlite index on df2\n\ncheckIdentical(argSpecs);\n\ntestAllJoinTypes(argSpecs,metric='median');\n##    join    merge data.table.unkeyed data.table.keyed sqldf.unindexed sqldf.indexed      plyr    dplyr in.place         unit\n## 1 inner  644.259           861.9345          923.516        9157.752      1580.390  959.2250 270.9190       NA microseconds\n## 2  left  713.539           888.0205          910.045        8820.334      1529.714  968.4195 270.9185 224.3045 microseconds\n## 3 right 1221.804           909.1900          923.944        8930.668      1533.135 1063.7860 269.8495 218.1035 microseconds\n## 4  full 1302.203          3107.5380         3184.729              NA            NA 1593.6475 270.7055       NA microseconds\n</code></pre>\n\n<hr>\n\n<p>Here I benchmark on random input data, trying different scales and different patterns of key overlap between the two input tables. This benchmark is still restricted to the case of a single-column integer key. As well, to ensure that the in-place solution would work for both left and right joins of the same tables, all random test data uses <code>0..1:0..1</code> cardinality. This is implemented by sampling without replacement the key column of the first data.frame when generating the key column of the second data.frame.</p>\n\n<pre><code>makeArgSpecs.singleIntegerKey.optionalOneToOne &lt;- function(size,overlap) {\n\n    com &lt;- as.integer(size*overlap);\n\n    argSpecs &lt;- list(\n        default=list(copySpec=1:2,args=list(\n            df1 &lt;- data.frame(id=sample(size),y1=rnorm(size),y2=rnorm(size)),\n            df2 &lt;- data.frame(id=sample(c(if (com&gt;0L) sample(df1$id,com) else integer(),seq(size+1L,len=size-com))),y3=rnorm(size),y4=rnorm(size)),\n            'id'\n        )),\n        data.table.unkeyed=list(copySpec=1:2,args=list(\n            as.data.table(df1),\n            as.data.table(df2),\n            'id'\n        )),\n        data.table.keyed=list(copySpec=1:2,args=list(\n            setkey(as.data.table(df1),id),\n            setkey(as.data.table(df2),id)\n        ))\n    );\n    ## prepare sqldf\n    initSqldf();\n    sqldf('create index df1_key on df1(id);'); ## upload and create an sqlite index on df1\n    sqldf('create index df2_key on df2(id);'); ## upload and create an sqlite index on df2\n\n    argSpecs;\n\n}; ## end makeArgSpecs.singleIntegerKey.optionalOneToOne()\n\n## cross of various input sizes and key overlaps\nsizes &lt;- c(1e1L,1e3L,1e6L);\noverlaps &lt;- c(0.99,0.5,0.01);\nsystem.time({ res &lt;- testGrid(makeArgSpecs.singleIntegerKey.optionalOneToOne,sizes,overlaps); });\n##     user   system  elapsed\n## 22024.65 12308.63 34493.19\n</code></pre>\n\n<p>I wrote some code to create log-log plots of the above results. I generated a separate plot for each overlap percentage. It's a little bit cluttered, but I like having all the solution types and join types represented in the same plot.</p>\n\n<p>I used spline interpolation to show a smooth curve for each solution/join type combination, drawn with individual pch symbols. The join type is captured by the pch symbol, using a dot for inner, left and right angle brackets for left and right, and a diamond for full. The solution type is captured by the color as shown in the legend.</p>\n\n<pre><code>plotRes &lt;- function(res,titleFunc,useFloor=F) {\n    solTypes &lt;- setdiff(names(res),c('size','overlap','joinType','unit')); ## derive from res\n    normMult &lt;- c(microseconds=1e-3,milliseconds=1); ## normalize to milliseconds\n    joinTypes &lt;- getJoinTypes();\n    cols &lt;- c(merge='purple',data.table.unkeyed='blue',data.table.keyed='#00DDDD',sqldf.unindexed='brown',sqldf.indexed='orange',plyr='red',dplyr='#00BB00',in.place='magenta');\n    pchs &lt;- list(inner=20L,left='&lt;',right='&gt;',full=23L);\n    cexs &lt;- c(inner=0.7,left=1,right=1,full=0.7);\n    NP &lt;- 60L;\n    ord &lt;- order(decreasing=T,colMeans(res[res$size==max(res$size),solTypes],na.rm=T));\n    ymajors &lt;- data.frame(y=c(1,1e3),label=c('1ms','1s'),stringsAsFactors=F);\n    for (overlap in unique(res$overlap)) {\n        x1 &lt;- res[res$overlap==overlap,];\n        x1[solTypes] &lt;- x1[solTypes]*normMult[x1$unit]; x1$unit &lt;- NULL;\n        xlim &lt;- c(1e1,max(x1$size));\n        xticks &lt;- 10^seq(log10(xlim[1L]),log10(xlim[2L]));\n        ylim &lt;- c(1e-1,10^((if (useFloor) floor else ceiling)(log10(max(x1[solTypes],na.rm=T))))); ## use floor() to zoom in a little more, only sqldf.unindexed will break above, but xpd=NA will keep it visible\n        yticks &lt;- 10^seq(log10(ylim[1L]),log10(ylim[2L]));\n        yticks.minor &lt;- rep(yticks[-length(yticks)],each=9L)*1:9;\n        plot(NA,xlim=xlim,ylim=ylim,xaxs='i',yaxs='i',axes=F,xlab='size (rows)',ylab='time (ms)',log='xy');\n        abline(v=xticks,col='lightgrey');\n        abline(h=yticks.minor,col='lightgrey',lty=3L);\n        abline(h=yticks,col='lightgrey');\n        axis(1L,xticks,parse(text=sprintf('10^%d',as.integer(log10(xticks)))));\n        axis(2L,yticks,parse(text=sprintf('10^%d',as.integer(log10(yticks)))),las=1L);\n        axis(4L,ymajors$y,ymajors$label,las=1L,tick=F,cex.axis=0.7,hadj=0.5);\n        for (joinType in rev(joinTypes)) { ## reverse to draw full first, since it's larger and would be more obtrusive if drawn last\n            x2 &lt;- x1[x1$joinType==joinType,];\n            for (solType in solTypes) {\n                if (any(!is.na(x2[[solType]]))) {\n                    xy &lt;- spline(x2$size,x2[[solType]],xout=10^(seq(log10(x2$size[1L]),log10(x2$size[nrow(x2)]),len=NP)));\n                    points(xy$x,xy$y,pch=pchs[[joinType]],col=cols[solType],cex=cexs[joinType],xpd=NA);\n                }; ## end if\n            }; ## end for\n        }; ## end for\n        ## custom legend\n        ## due to logarithmic skew, must do all distance calcs in inches, and convert to user coords afterward\n        ## the bottom-left corner of the legend will be defined in normalized figure coords, although we can convert to inches immediately\n        leg.cex &lt;- 0.7;\n        leg.x.in &lt;- grconvertX(0.275,'nfc','in');\n        leg.y.in &lt;- grconvertY(0.6,'nfc','in');\n        leg.x.user &lt;- grconvertX(leg.x.in,'in');\n        leg.y.user &lt;- grconvertY(leg.y.in,'in');\n        leg.outpad.w.in &lt;- 0.1;\n        leg.outpad.h.in &lt;- 0.1;\n        leg.midpad.w.in &lt;- 0.1;\n        leg.midpad.h.in &lt;- 0.1;\n        leg.sol.w.in &lt;- max(strwidth(solTypes,'in',leg.cex));\n        leg.sol.h.in &lt;- max(strheight(solTypes,'in',leg.cex))*1.5; ## multiplication factor for greater line height\n        leg.join.w.in &lt;- max(strheight(joinTypes,'in',leg.cex))*1.5; ## ditto\n        leg.join.h.in &lt;- max(strwidth(joinTypes,'in',leg.cex));\n        leg.main.w.in &lt;- leg.join.w.in*length(joinTypes);\n        leg.main.h.in &lt;- leg.sol.h.in*length(solTypes);\n        leg.x2.user &lt;- grconvertX(leg.x.in+leg.outpad.w.in*2+leg.main.w.in+leg.midpad.w.in+leg.sol.w.in,'in');\n        leg.y2.user &lt;- grconvertY(leg.y.in+leg.outpad.h.in*2+leg.main.h.in+leg.midpad.h.in+leg.join.h.in,'in');\n        leg.cols.x.user &lt;- grconvertX(leg.x.in+leg.outpad.w.in+leg.join.w.in*(0.5+seq(0L,length(joinTypes)-1L)),'in');\n        leg.lines.y.user &lt;- grconvertY(leg.y.in+leg.outpad.h.in+leg.main.h.in-leg.sol.h.in*(0.5+seq(0L,length(solTypes)-1L)),'in');\n        leg.sol.x.user &lt;- grconvertX(leg.x.in+leg.outpad.w.in+leg.main.w.in+leg.midpad.w.in,'in');\n        leg.join.y.user &lt;- grconvertY(leg.y.in+leg.outpad.h.in+leg.main.h.in+leg.midpad.h.in,'in');\n        rect(leg.x.user,leg.y.user,leg.x2.user,leg.y2.user,col='white');\n        text(leg.sol.x.user,leg.lines.y.user,solTypes[ord],cex=leg.cex,pos=4L,offset=0);\n        text(leg.cols.x.user,leg.join.y.user,joinTypes,cex=leg.cex,pos=4L,offset=0,srt=90); ## srt rotation applies *after* pos/offset positioning\n        for (i in seq_along(joinTypes)) {\n            joinType &lt;- joinTypes[i];\n            points(rep(leg.cols.x.user[i],length(solTypes)),ifelse(colSums(!is.na(x1[x1$joinType==joinType,solTypes[ord]]))==0L,NA,leg.lines.y.user),pch=pchs[[joinType]],col=cols[solTypes[ord]]);\n        }; ## end for\n        title(titleFunc(overlap));\n        readline(sprintf('overlap %.02f',overlap));\n    }; ## end for\n}; ## end plotRes()\n\ntitleFunc &lt;- function(overlap) sprintf('R merge solutions: single-column integer key, 0..1:0..1 cardinality, %d%% overlap',as.integer(overlap*100));\nplotRes(res,titleFunc,T);\n</code></pre>\n\n<p><a href=\"https://i.stack.imgur.com/yvTPK.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/yvTPK.png\" alt=\"R-merge-benchmark-single-column-integer-key-optional-one-to-one-99\"></a></p>\n\n<p><a href=\"https://i.stack.imgur.com/kUyPB.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/kUyPB.png\" alt=\"R-merge-benchmark-single-column-integer-key-optional-one-to-one-50\"></a></p>\n\n<p><a href=\"https://i.stack.imgur.com/vAuxQ.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/vAuxQ.png\" alt=\"R-merge-benchmark-single-column-integer-key-optional-one-to-one-1\"></a></p>\n\n<hr>\n\n<p>Here's a second large-scale benchmark that's more heavy-duty, with respect to the number and types of key columns, as well as cardinality. For this benchmark I use three key columns: one character, one integer, and one logical, with no restrictions on cardinality (that is, <code>0..*:0..*</code>). (In general it's not advisable to define key columns with double or complex values due to floating-point comparison complications, and basically no one ever uses the raw type, much less for key columns, so I haven't included those types in the key columns. Also, for information's sake, I initially tried to use four key columns by including a POSIXct key column, but the POSIXct type didn't play well with the <code>sqldf.indexed</code> solution for some reason, possibly due to floating-point comparison anomalies, so I removed it.)</p>\n\n<pre><code>makeArgSpecs.assortedKey.optionalManyToMany &lt;- function(size,overlap,uniquePct=75) {\n\n    ## number of unique keys in df1\n    u1Size &lt;- as.integer(size*uniquePct/100);\n\n    ## (roughly) divide u1Size into bases, so we can use expand.grid() to produce the required number of unique key values with repetitions within individual key columns\n    ## use ceiling() to ensure we cover u1Size; will truncate afterward\n    u1SizePerKeyColumn &lt;- as.integer(ceiling(u1Size^(1/3)));\n\n    ## generate the unique key values for df1\n    keys1 &lt;- expand.grid(stringsAsFactors=F,\n        idCharacter=replicate(u1SizePerKeyColumn,paste(collapse='',sample(letters,sample(4:12,1L),T))),\n        idInteger=sample(u1SizePerKeyColumn),\n        idLogical=sample(c(F,T),u1SizePerKeyColumn,T)\n        ##idPOSIXct=as.POSIXct('2016-01-01 00:00:00','UTC')+sample(u1SizePerKeyColumn)\n    )[seq_len(u1Size),];\n\n    ## rbind some repetitions of the unique keys; this will prepare one side of the many-to-many relationship\n    ## also scramble the order afterward\n    keys1 &lt;- rbind(keys1,keys1[sample(nrow(keys1),size-u1Size,T),])[sample(size),];\n\n    ## common and unilateral key counts\n    com &lt;- as.integer(size*overlap);\n    uni &lt;- size-com;\n\n    ## generate some unilateral keys for df2 by synthesizing outside of the idInteger range of df1\n    keys2 &lt;- data.frame(stringsAsFactors=F,\n        idCharacter=replicate(uni,paste(collapse='',sample(letters,sample(4:12,1L),T))),\n        idInteger=u1SizePerKeyColumn+sample(uni),\n        idLogical=sample(c(F,T),uni,T)\n        ##idPOSIXct=as.POSIXct('2016-01-01 00:00:00','UTC')+u1SizePerKeyColumn+sample(uni)\n    );\n\n    ## rbind random keys from df1; this will complete the many-to-many relationship\n    ## also scramble the order afterward\n    keys2 &lt;- rbind(keys2,keys1[sample(nrow(keys1),com,T),])[sample(size),];\n\n    ##keyNames &lt;- c('idCharacter','idInteger','idLogical','idPOSIXct');\n    keyNames &lt;- c('idCharacter','idInteger','idLogical');\n    ## note: was going to use raw and complex type for two of the non-key columns, but data.table doesn't seem to fully support them\n    argSpecs &lt;- list(\n        default=list(copySpec=1:2,args=list(\n            df1 &lt;- cbind(stringsAsFactors=F,keys1,y1=sample(c(F,T),size,T),y2=sample(size),y3=rnorm(size),y4=replicate(size,paste(collapse='',sample(letters,sample(4:12,1L),T)))),\n            df2 &lt;- cbind(stringsAsFactors=F,keys2,y5=sample(c(F,T),size,T),y6=sample(size),y7=rnorm(size),y8=replicate(size,paste(collapse='',sample(letters,sample(4:12,1L),T)))),\n            keyNames\n        )),\n        data.table.unkeyed=list(copySpec=1:2,args=list(\n            as.data.table(df1),\n            as.data.table(df2),\n            keyNames\n        )),\n        data.table.keyed=list(copySpec=1:2,args=list(\n            setkeyv(as.data.table(df1),keyNames),\n            setkeyv(as.data.table(df2),keyNames)\n        ))\n    );\n    ## prepare sqldf\n    initSqldf();\n    sqldf(paste0('create index df1_key on df1(',paste(collapse=',',keyNames),');')); ## upload and create an sqlite index on df1\n    sqldf(paste0('create index df2_key on df2(',paste(collapse=',',keyNames),');')); ## upload and create an sqlite index on df2\n\n    argSpecs;\n\n}; ## end makeArgSpecs.assortedKey.optionalManyToMany()\n\nsizes &lt;- c(1e1L,1e3L,1e5L); ## 1e5L instead of 1e6L to respect more heavy-duty inputs\noverlaps &lt;- c(0.99,0.5,0.01);\nsolTypes &lt;- setdiff(getSolTypes(),'in.place');\nsystem.time({ res &lt;- testGrid(makeArgSpecs.assortedKey.optionalManyToMany,sizes,overlaps,solTypes); });\n##     user   system  elapsed\n## 38895.50   784.19 39745.53\n</code></pre>\n\n<p>The resulting plots, using the same plotting code given above:</p>\n\n<pre><code>titleFunc &lt;- function(overlap) sprintf('R merge solutions: character/integer/logical key, 0..*:0..* cardinality, %d%% overlap',as.integer(overlap*100));\nplotRes(res,titleFunc,F);\n</code></pre>\n\n<p><a href=\"https://i.stack.imgur.com/7gShO.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/7gShO.png\" alt=\"R-merge-benchmark-assorted-key-optional-many-to-many-99\"></a></p>\n\n<p><a href=\"https://i.stack.imgur.com/yTeRO.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/yTeRO.png\" alt=\"R-merge-benchmark-assorted-key-optional-many-to-many-50\"></a></p>\n\n<p><a href=\"https://i.stack.imgur.com/buxZ2.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/buxZ2.png\" alt=\"R-merge-benchmark-assorted-key-optional-many-to-many-1\"></a></p>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>For an inner join on all columns, you could also use <code>fintersect</code> from the <em>data.table</em>-package or <code>intersect</code> from the <em>dplyr</em>-package as an alternative to <code>merge</code> without specifying the <code>by</code>-columns. this will give the rows that are equal between two dataframes:</p>\n\n<pre><code>merge(df1, df2)\n#   V1 V2\n# 1  B  2\n# 2  C  3\ndplyr::intersect(df1, df2)\n#   V1 V2\n# 1  B  2\n# 2  C  3\ndata.table::fintersect(setDT(df1), setDT(df2))\n#    V1 V2\n# 1:  B  2\n# 2:  C  3\n</code></pre>\n\n<hr>\n\n<p>Example data:</p>\n\n<pre><code>df1 &lt;- data.frame(V1 = LETTERS[1:4], V2 = 1:4)\ndf2 &lt;- data.frame(V1 = LETTERS[2:3], V2 = 2:3)\n</code></pre>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<ol>\n<li>Using <code>merge</code> function we can select the variable of left table or right table, same way like we all familiar with select statement in SQL (EX : Select a.* ...or Select b.* from .....)</li>\n<li><p>We have to add extra code which will subset from the newly joined table .</p>\n\n<ul>\n<li><p>SQL :-  <code>select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId</code></p></li>\n<li><p>R :- <code>merge(df1, df2, by.x = \"CustomerId\", by.y = \"CustomerId\")[,names(df1)]</code></p></li>\n</ul></li>\n</ol>\n\n<p>Same way </p>\n\n<ul>\n<li><p>SQL :- <code>select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId</code></p></li>\n<li><p>R :- <code>merge(df1, df2, by.x = \"CustomerId\", by.y =\n\"CustomerId\")[,names(df2)]</code></p></li>\n</ul>\n    </div>", "qid": 48515897, "link": "https://stackoverflow.com/a/1300618", "id": 1300618}
{"answer": "<div class=\"post-text\" itemprop=\"text\">\r\n<p>You are not using correct key with <code>.data()</code> method.</p>\n\n<p><em>Use</em></p>\n\n<pre><code> var Idimp = $(this).data('curatedId');\n</code></pre>\n\n<p><em>instead of</em></p>\n\n<pre><code> var Idimp = $(this).data('data-curated-id');\n</code></pre>\n    </div>", "qid": 48515971, "link": "https://stackoverflow.com/a/48515982", "id": 48515982}
